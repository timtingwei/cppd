# ex2_01
>int,long,long long,short的区别是什么

int是整型，最小尺寸16位
long是长整型，最小尺寸32位
long long是长整型，最小尺寸64位
short是短整型，最小尺寸16位
长整型至少和整型一样长，整型至少和短整型一样长
>无符号类型和带符号类型的区别是什么?

带符号类型可以表示正数,负数或0，无符号类型则仅能表示大于等于0的值。
>float和double的区别是什么?

float是单精度浮点数，最小位数是6位有效数字
double是双精度浮点数，最小位数是10位有效数字
通常在执行浮点数运算中选用double。
# ex2_02
>利率4.86%

适合用double双精度浮点数，考虑到不会为负可以加上unsigned
>本金10000

适合用int
>付款440.51

适合用double

# ex2_03&ex2_04
>输出结果
```
u2-u 输出:32
u-u2 输出:4294967264
i2-i 输出:32
i-i2 输出:-32
i-u  输出:0
u-i  输出:0
```
# ex2_05
>(a)

'a'--字符字面值,类型为char

L'a'--宽字符型字面值，类型是wchar_t

"a"--字符串字面值，是由常量字符构成的数组(array)

L"a"--宽字符串型字面值

宽字符与字符的区别在于所占的字符数，但实际上并没有规定char占几位，更多的区别在于本地化策略集对于二者做如何规定。
>(b)

10--整型字面值,类型是int

10u--无符号的整型字面值，类型是unsigned

10uL--无符号整型字面值，类型是unsigned long long

012--八进制数，表示十进制数的10

0xC--十六进制数
>(c)

3.14--浮点型字面值，类型为double

3.14f--浮点型字面值，类型为float

3.14L--浮点型字面值，类型为long double
>(d)

10--整型字面值,类型是int

10u--无符号的整型字面值，类型是unsigned

10.--浮点型字面值，类型是double

10e-2--浮点型字面值，类型是double

# ex2_06
有区别，9与7表示的十进制，而09与07表示的是八进制,然而八进制里面没有9这个数，所以用09初始化值会报错。

# ex2_07
>(a),输出:
```
Who goes with Fergus?
```
数据类型是字符串字面值，中间转义了字母e和一个换行符
>(b),输出:
```
31.4
```
数据类型是long double
>(c),报错:
```
unable to find numeric literal operator operator f
```
>(d),输出:
```
3.14
```
数据类型是long double

# ex2_09
>(a)

定义变量 input_value 为int类型

>(b)

错误，转换未执行，因为存在丢失信息的危险
应改为: int i = (3.14) or int i = 3.14

>(c)

错误，wage并没有定义，应该先初始化wage，然后将wage的值赋给salary

>(d)

将浮点数转化为整数

# ex2_10
global_str被定义为空串
global_int被定义为0
local_int未定义
local_str未定义

# ex2_11
(a)定义

(b)声明并定义

(c)声明

# ex2_12
非法: (b),(c),(d)

# ex2_13
j的值是42

# ex2_14
合法，输出100 45。

# ex2_15
(b)不合法，引用类型的初始值必须是一个对象

(d)不合法，引用类型必须初始化

# ex2_16
都合法

(a) r2作为d的引用，将3.14159的值赋给了d

(b) r1作为i的引用，将i的值赋给了d

(c)将d的值赋给了i

(d)将d的值赋给了i

# ex2_17
输出
```
10 10
```

# ex2_18
```
int v = 1 , v1 = 2 , *p = &v;
p = &v1; //更改指针的地址为v1
*p = 3;  //更改v1的值为3
```

# ex2_19

1，指针本身是对象，而引用本身不是对象

2，指针在生命周期内可以先后指向几个不同的对象，而引用被初始化后就无法改变

3，指针无须在定义时赋值，而引用则必须赋值。

# ex2_20
这段代码做了个乘法————42*42

# ex2_21

>(a),不合法
因为指针类型与它所指的类型不同

>(b),不合法
指针赋予初始值时缺少&

>(c)，合法

# ex2_22
```
if(p) //如果p有指向的内容，则为True
if(*p) //判断的是p指向的内容是否为0
```

# ex2_23
不能，首先要判断指针的合法性。

# ex2_24
因为void类型的指针可以指向任意对象，而long类型的指针只能指向long类型。

# ex2_25

>(a)

ip:是指针，指向i

i:是int类型,值未定义

r:是i的引用，值就是i

>(b)

i:是int类型,值未定义

ip:是int类型的空指针

>(c)

ip:是int类型的未定义指针

ip2:是int类型，值未定义

# ex2_26

>(a),不合法:

常量必须初始化

>(b),合法

>(c),合法

>(d),不合法，常量不可改变

# ex2_27
(a)错误，引用的初始化对象一定是个对象

(b)合法，初始化了一个本身是常量的指针

(c)错误，原因同(a)

(d)合法，初始化了一个指向常量的常量指针

(e)合法，初始化了一个指向常量的指针

(f)错误，引用不是对象，无法对其常量化

(g)合法

# ex2_28
(a)cp不合法,定义了一个int类型的整数i,常量指针cp必须初始化

(b)p2不合法，定义指针p1,常量指针p2必须初始化

(c)定义常量ic与引用了常量ic的r

(d)不合法，定义指向常量的常量指针p3必须初始化

(e)定义指向常量的指针p

# ex2_29

(a)合法

(b)合法

(c)错误，p1只是一个普通指针

(d)错误，常量指针不会改变地址

(e)错误，常量指针不会改变地址

(f)错误，常量不会改变

# ex2_30
顶层cost:v2,p3

底层cost:p2,p3

# ex2_31

r1 = v2 合法，v2是一个顶层cost，r1是一个变量的引用，所以无影响

p1 = p2 不合法，p1是一个普通指针，p2是一个底层指针，p1无法指向常量

p2 = p1 合法，底层指针对于普通指针的拷贝可以成立

p1 = p3 不合法，p1是一个普通指针，p3是一个底层指针也是一个顶层指针，p1无法指向常量

p2 = p3 合法,p2与p3的类型上面介绍了他们都是底层的

# ex2_32
不合法，修改为:
```
int null = 0,*p = null;
```

# ex2_33

a = 42,合法

b = 42,合法

c = 42,合法

d = 42,不合法，d是一个整型指数，想要给d指向的地址赋值应该:*d = 42

e = 42,不合法，e是一个指向整型常量的执政

g = 42,不合法，g是一个整型常量的引用，无法改变常量的值

# ex2_34(略)

# ex2_35

i:整型常量

j:整型常量

k:对整型常量的整型引用

p:对整型常量的指针

j2:整型常量

k2:对整型常量的整型引用

# ex2_36

a,整型,4

b,整型,4

c,整型,4

d,对整型的引用,4

# ex2_37

a,整型,3

b,整型,4

c,整型,3

d,对整型的引用,3

# ex2_38

>decltype处理顶层const和引用的方式与auto有些许不同

>decltyp和auto的另一处重要区别是,decltype的结果类型与表达式形式密切相关。

一样的:

```
int a = 1;
auto b = a;
decltype(a) c = a;
```
不一样的:
```
const int a = 1;
auto b = a; //b的类型是整型，const被忽略
decltype(a) c = a; //c的类型是常数整型,const未被忽略
decltype((a)) d = a; //d的类型是指向常量整数的引用
```
# ex2_39
>报错:
```
error:expected':' after struct definition struct Foo {}
```

# ex2_40(略)

